package generator

import "fmt"
import (
    "sync"
    "time"
)

/*
This generator iterates over all keys.

(*MapGenerator[K,V]) implements the interface Generator[K]

MapGenerators need to be started before they can be used. To start one, call the Start method

If one wants to iterate over the values instead of the keys, then one can use the Values method
This method does not necessitate, but does tolerate, the map being already started
*/
type MapGenerator[K comparable, V any] struct {
	stopchan chan bool
	returned chan K
	stopped  bool
    started bool
    stoppingLock sync.RWMutex
}

/*
Initializes the MapGenerator

Arguments:

-m : the map which is iterated upon
*/
func (mg *MapGenerator[K, V]) Start(m map[K]V) {
    if mg == nil {panic("Cannot start <nil> generator")}
	mg.returned = make(chan K)
	mg.stopchan = make(chan bool)

	go func() {

		for k, _ := range m {
			fmt.Println(k)
			select {
			case mg.returned <- k:
			case <-mg.stopchan:
                mg.stoppingLock.Lock()
                defer mg.stoppingLock.Unlock()
				mg.stopped = true
				return
			}
		}
        mg.stoppingLock.Lock()
        defer mg.stoppingLock.Unlock()
		fmt.Println("stopping")
		mg.stopped = true
        return
	}()

    mg.started = true
}

// Returns the next element of the generator, if the generator is finished, returns true. Does return the last element
func (mg *MapGenerator[K, V]) Next() (K, bool) {
    default_k := *(new(K))
    if mg == nil {panic("cannot next <nil> generator")}

    if !mg.started {
        time.Sleep(3000*time.Microsecond)
        if !mg.started {
            panic("Generator not started")
        } else {
            return mg.Next()
        }
    }

    for {
        mg.stoppingLock.RLock()
        if mg.stopped {
            mg.stoppingLock.RUnlock()
            return default_k, true
        } else {
            mg.stoppingLock.RUnlock()
            select {
            case e := <-mg.returned:
                return e, false
            case <- time.After(300*time.Microsecond):
                continue
            }
        }
    }
}

/*
Stops the MapGenerator.
*/
func (mg *MapGenerator[K, V]) Stop() {
	mg.stopchan <- true
}

/*
Returns a new Generator that iterates over the values of the map instead of iterating over the keys.

This method does not necessitate that the MapGenerator be started. However, it can function in this case.
*/
func (mg *MapGenerator[K, V]) Values(m map[K]V) Generator[V] {
    if !mg.started {
        mg.Start(m)
    }

    with := func(k K) V { return m[k] }
	return Transform[K, V](mg, with)
}

/*
A (key, value) pair.

Can be generated by using a map generator's Items method
*/
type MapItem[K, V any]struct{
    Key K // the key of the pair
    Val V // the value of the pair
}

/*
Functions identically than the Values method but instead returns a (key, value) pair :

It returns a new Generator that iterates over (key, value) pairs in the map instead of just the keys.

This method does not necessitate that the MapGenerator be started. However, it can function in this case.
*/
func (mg *MapGenerator[K,V]) Items(m map[K]V) Generator[MapItem[K, V]] {
    if !mg.started {
        mg.Start(m)
    }

    with := func(k K) MapItem[K,V] {return MapItem[K,V]{Key:k, Val:m[k]}}
    return Transform[K, MapItem[K, V]](mg, with)
}
